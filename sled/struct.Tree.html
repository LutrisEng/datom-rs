<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A flash-sympathetic persistent lock-free B+ tree."><title>Tree in sled - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e883e87179a81222.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="sled" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0-nightly (de686cbc6 2023-12-14)" data-channel="nightly" data-search-js="search-874d56868bf05518.js" data-settings-js="settings-fe03fdc259827cd2.js" ><script src="../static.files/storage-bc37acceda91d44a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-77dede896d6ac08e.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../sled/index.html"><img src="https://raw.githubusercontent.com/spacejam/sled/master/art/tree_face_anti-transphobia.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../sled/index.html"><img src="https://raw.githubusercontent.com/spacejam/sled/master/art/tree_face_anti-transphobia.png" alt="logo"></a><h2><a href="../sled/index.html">sled</a><span class="version">0.34.7</span></h2></div><h2 class="location"><a href="#">Tree</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.apply_batch">apply_batch</a></li><li><a href="#method.checksum">checksum</a></li><li><a href="#method.clear">clear</a></li><li><a href="#method.compare_and_swap">compare_and_swap</a></li><li><a href="#method.contains_key">contains_key</a></li><li><a href="#method.fetch_and_update">fetch_and_update</a></li><li><a href="#method.first">first</a></li><li><a href="#method.flush">flush</a></li><li><a href="#method.flush_async">flush_async</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_gt">get_gt</a></li><li><a href="#method.get_lt">get_lt</a></li><li><a href="#method.insert">insert</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.last">last</a></li><li><a href="#method.len">len</a></li><li><a href="#method.merge">merge</a></li><li><a href="#method.name">name</a></li><li><a href="#method.pop_max">pop_max</a></li><li><a href="#method.pop_min">pop_min</a></li><li><a href="#method.range">range</a></li><li><a href="#method.remove">remove</a></li><li><a href="#method.scan_prefix">scan_prefix</a></li><li><a href="#method.set_merge_operator">set_merge_operator</a></li><li><a href="#method.transaction">transaction</a></li><li><a href="#method.update_and_fetch">update_and_fetch</a></li><li><a href="#method.watch_prefix">watch_prefix</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Tree">Clone</a></li><li><a href="#impl-Debug-for-Tree">Debug</a></li><li><a href="#impl-Deref-for-Tree">Deref</a></li><li><a href="#impl-IntoIterator-for-%26Tree">IntoIterator</a></li><li><a href="#impl-Send-for-Tree">Send</a></li><li><a href="#impl-Sync-for-Tree">Sync</a></li><li><a href="#impl-Transactional%3CE%3E-for-%26Tree">Transactional&lt;E&gt;</a></li><li><a href="#impl-Transactional%3CE%3E-for-Tree">Transactional&lt;E&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Tree">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-Tree">!UnwindSafe</a></li><li><a href="#impl-Unpin-for-Tree">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-Pointable-for-T">Pointable</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate sled</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">sled</a>::<wbr><a class="struct" href="#">Tree</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/sled/tree.rs.html#87">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Tree(<span class="comment">/* private fields */</span>);</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A flash-sympathetic persistent lock-free B+ tree.</p>
<p>A <code>Tree</code> represents a single logical keyspace / namespace / bucket.</p>
<p>Separate <code>Trees</code> may be opened to separate concerns using
<code>Db::open_tree</code>.</p>
<p><code>Db</code> implements <code>Deref&lt;Target = Tree&gt;</code> such that a <code>Db</code> acts
like the “default” <code>Tree</code>. This is the only <code>Tree</code> that cannot
be deleted via <code>Db::drop_tree</code>.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::IVec;

<span class="kw">let </span>db: sled::Db = sled::open(<span class="string">"db"</span>)<span class="question-mark">?</span>;
db.insert(<span class="string">b"yo!"</span>, <span class="string">b"v1"</span>.to_vec());
<span class="macro">assert_eq!</span>(db.get(<span class="string">b"yo!"</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(IVec::from(<span class="string">b"v1"</span>))));

<span class="comment">// Atomic compare-and-swap.
</span>db.compare_and_swap(
    <span class="string">b"yo!"</span>,      <span class="comment">// key
    </span><span class="prelude-val">Some</span>(<span class="string">b"v1"</span>), <span class="comment">// old value, None for not present
    </span><span class="prelude-val">Some</span>(<span class="string">b"v2"</span>), <span class="comment">// new value, None for delete
</span>)<span class="question-mark">?</span>;

<span class="comment">// Iterates over key-value pairs, starting at the given key.
</span><span class="kw">let </span>scan_key: <span class="kw-2">&amp;</span>[u8] = <span class="string">b"a non-present key before yo!"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>iter = db.range(scan_key..);
<span class="macro">assert_eq!</span>(
    iter.next().unwrap(),
    <span class="prelude-val">Ok</span>((IVec::from(<span class="string">b"yo!"</span>), IVec::from(<span class="string">b"v2"</span>)))
);
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);

db.remove(<span class="string">b"yo!"</span>);
<span class="macro">assert_eq!</span>(db.get(<span class="string">b"yo!"</span>), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));

<span class="kw">let </span>other_tree: sled::Tree = db.open_tree(<span class="string">b"cool db facts"</span>)<span class="question-mark">?</span>;
other_tree.insert(
    <span class="string">b"k1"</span>,
    <span class="kw-2">&amp;</span><span class="string">b"a Db acts like a Tree due to implementing Deref&lt;Target = Tree&gt;"</span>[..]
)<span class="question-mark">?</span>;</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Tree" class="impl"><a class="src rightside" href="../src/sled/tree.rs.html#129-2134">source</a><a href="#impl-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.insert" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#153-169">source</a><h4 class="code-header">pub fn <a href="#method.insert" class="fn">insert</a>&lt;K, V&gt;(&amp;self, key: K, value: V) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Insert a key to a new value, returning the last value if it
was set.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(db.insert(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="macro">vec!</span>[<span class="number">0</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));
<span class="macro">assert_eq!</span>(db.insert(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="macro">vec!</span>[<span class="number">1</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(sled::IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>]))));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.transaction" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#338-348">source</a><h4 class="code-header">pub fn <a href="#method.transaction" class="fn">transaction</a>&lt;F, A, E&gt;(&amp;self, f: F) -&gt; <a class="type" href="transaction/type.TransactionResult.html" title="type sled::transaction::TransactionResult">TransactionResult</a>&lt;A, E&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;<a class="struct" href="transaction/struct.TransactionalTree.html" title="struct sled::transaction::TransactionalTree">TransactionalTree</a>) -&gt; <a class="type" href="transaction/type.ConflictableTransactionResult.html" title="type sled::transaction::ConflictableTransactionResult">ConflictableTransactionResult</a>&lt;A, E&gt;,</div></h4></section></summary><div class="docblock"><p>Perform a multi-key serializable transaction.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Use write-only transactions as a writebatch:
</span>db.transaction(|tx_db| {
    tx_db.insert(<span class="string">b"k1"</span>, <span class="string">b"cats"</span>)<span class="question-mark">?</span>;
    tx_db.insert(<span class="string">b"k2"</span>, <span class="string">b"dogs"</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
})<span class="question-mark">?</span>;

<span class="comment">// Atomically swap two items:
</span>db.transaction(|tx_db| {
    <span class="kw">let </span>v1_option = tx_db.remove(<span class="string">b"k1"</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span>v1 = v1_option.unwrap();
    <span class="kw">let </span>v2_option = tx_db.remove(<span class="string">b"k2"</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span>v2 = v2_option.unwrap();

    tx_db.insert(<span class="string">b"k1"</span>, v2)<span class="question-mark">?</span>;
    tx_db.insert(<span class="string">b"k2"</span>, v1)<span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
})<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.get(<span class="string">b"k1"</span>)<span class="question-mark">?</span>.unwrap(), <span class="string">b"dogs"</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.get(<span class="string">b"k2"</span>)<span class="question-mark">?</span>.unwrap(), <span class="string">b"cats"</span>);</code></pre></div>
<p>A transaction may return information from
an intentionally-cancelled transaction by using
the abort function inside the closure in
combination with the try operator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::{transaction::{abort, TransactionError, TransactionResult}, Config};

<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">struct </span>MyBullshitError;

<span class="kw">fn </span>main() -&gt; TransactionResult&lt;(), MyBullshitError&gt; {
    <span class="kw">let </span>config = Config::new().temporary(<span class="bool-val">true</span>);
    <span class="kw">let </span>db = config.open()<span class="question-mark">?</span>;

    <span class="comment">// Use write-only transactions as a writebatch:
    </span><span class="kw">let </span>res = db.transaction(|tx_db| {
        tx_db.insert(<span class="string">b"k1"</span>, <span class="string">b"cats"</span>)<span class="question-mark">?</span>;
        tx_db.insert(<span class="string">b"k2"</span>, <span class="string">b"dogs"</span>)<span class="question-mark">?</span>;
        <span class="comment">// aborting will cause all writes to roll-back.
        </span><span class="kw">if </span><span class="bool-val">true </span>{
            abort(MyBullshitError)<span class="question-mark">?</span>;
        }
        <span class="prelude-val">Ok</span>(<span class="number">42</span>)
    }).unwrap_err();

    <span class="macro">assert_eq!</span>(res, TransactionError::Abort(MyBullshitError));
    <span class="macro">assert_eq!</span>(db.get(<span class="string">b"k1"</span>)<span class="question-mark">?</span>, <span class="prelude-val">None</span>);
    <span class="macro">assert_eq!</span>(db.get(<span class="string">b"k2"</span>)<span class="question-mark">?</span>, <span class="prelude-val">None</span>);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Transactions also work on tuples of <code>Tree</code>s,
preserving serializable ACID semantics!
In this example, we treat two trees like a
work queue, atomically apply updates to
data and move them from the unprocessed <code>Tree</code>
to the processed <code>Tree</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::Transactional;

<span class="kw">let </span>unprocessed = db.open_tree(<span class="string">b"unprocessed items"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>processed = db.open_tree(<span class="string">b"processed items"</span>)<span class="question-mark">?</span>;

<span class="comment">// An update somehow gets into the tree, which we
// later trigger the atomic processing of.
</span>unprocessed.insert(<span class="string">b"k3"</span>, <span class="string">b"ligers"</span>)<span class="question-mark">?</span>;

<span class="comment">// Atomically process the new item and move it
// between `Tree`s.
</span>(<span class="kw-2">&amp;</span>unprocessed, <span class="kw-2">&amp;</span>processed)
    .transaction(|(tx_unprocessed, tx_processed)| {
        <span class="kw">let </span>unprocessed_item = tx_unprocessed.remove(<span class="string">b"k3"</span>)<span class="question-mark">?</span>.unwrap();
        <span class="kw">let </span><span class="kw-2">mut </span>processed_item = <span class="string">b"yappin' "</span>.to_vec();
        processed_item.extend_from_slice(<span class="kw-2">&amp;</span>unprocessed_item);
        tx_processed.insert(<span class="string">b"k3"</span>, processed_item)<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(())
    })<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(unprocessed.get(<span class="string">b"k3"</span>).unwrap(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>processed.get(<span class="string">b"k3"</span>).unwrap().unwrap(), <span class="string">b"yappin' ligers"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.apply_batch" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#376-380">source</a><h4 class="code-header">pub fn <a href="#method.apply_batch" class="fn">apply_batch</a>(&amp;self, batch: <a class="struct" href="struct.Batch.html" title="struct sled::Batch">Batch</a>) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new batched update that can be
atomically applied.</p>
<p>It is possible to apply a <code>Batch</code> in a transaction
as well, which is the way you can apply a <code>Batch</code>
to multiple <code>Tree</code>s atomically.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>db.insert(<span class="string">"key_0"</span>, <span class="string">"val_0"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>batch = sled::Batch::default();
batch.insert(<span class="string">"key_a"</span>, <span class="string">"val_a"</span>);
batch.insert(<span class="string">"key_b"</span>, <span class="string">"val_b"</span>);
batch.insert(<span class="string">"key_c"</span>, <span class="string">"val_c"</span>);
batch.remove(<span class="string">"key_0"</span>);

db.apply_batch(batch)<span class="question-mark">?</span>;
<span class="comment">// key_0 no longer exists, and key_a, key_b, and key_c
// now do exist.</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#416-424">source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, key: K) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Retrieve a value from the <code>Tree</code> if it exists.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>], <span class="macro">vec!</span>[<span class="number">0</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(db.get(<span class="kw-2">&amp;</span>[<span class="number">0</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(sled::IVec::from(<span class="macro">vec!</span>[<span class="number">0</span>]))));
<span class="macro">assert_eq!</span>(db.get(<span class="kw-2">&amp;</span>[<span class="number">1</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#464-474">source</a><h4 class="code-header">pub fn <a href="#method.remove" class="fn">remove</a>&lt;K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, key: K) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Delete a value, returning the old value if it existed.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>db.insert(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="macro">vec!</span>[<span class="number">1</span>]);
<span class="macro">assert_eq!</span>(db.remove(<span class="kw-2">&amp;</span>[<span class="number">1</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(sled::IVec::from(<span class="macro">vec!</span>[<span class="number">1</span>]))));
<span class="macro">assert_eq!</span>(db.remove(<span class="kw-2">&amp;</span>[<span class="number">1</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compare_and_swap" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#527-595">source</a><h4 class="code-header">pub fn <a href="#method.compare_and_swap" class="fn">compare_and_swap</a>&lt;K, OV, NV&gt;(
    &amp;self,
    key: K,
    old: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;OV&gt;,
    new: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;NV&gt;
) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.CompareAndSwapError.html" title="struct sled::CompareAndSwapError">CompareAndSwapError</a>&gt;&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
    OV: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
    NV: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Compare and swap. Capable of unique creation, conditional modification,
or deletion. If old is <code>None</code>, this will only set the value if it
doesn’t exist yet. If new is <code>None</code>, will delete the value if old is
correct. If both old and new are <code>Some</code>, will modify the value if
old is correct.</p>
<p>It returns <code>Ok(Ok(()))</code> if operation finishes successfully.</p>
<p>If it fails it returns:
- <code>Ok(Err(CompareAndSwapError(current, proposed)))</code> if operation
failed to setup a new value. <code>CompareAndSwapError</code> contains
current and proposed values.
- <code>Err(Error::Unsupported)</code> if the database is opened in read-only
mode.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// unique creation
</span><span class="macro">assert_eq!</span>(
    db.compare_and_swap(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="prelude-val">None </span><span class="kw">as </span><span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>[u8]&gt;, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>])),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Ok</span>(()))
);

<span class="comment">// conditional modification
</span><span class="macro">assert_eq!</span>(
    db.compare_and_swap(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>]), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">20</span>])),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Ok</span>(()))
);

<span class="comment">// failed conditional modification -- the current value is returned in
// the error variant
</span><span class="kw">let </span>operation = db.compare_and_swap(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">30</span>]), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">40</span>]));
<span class="macro">assert!</span>(operation.is_ok()); <span class="comment">// the operation succeeded
</span><span class="kw">let </span>modification = operation.unwrap();
<span class="macro">assert!</span>(modification.is_err());
<span class="kw">let </span>actual_value = modification.unwrap_err();
<span class="macro">assert_eq!</span>(actual_value.current.map(|ivec| ivec.to_vec()), <span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="number">20</span>]));

<span class="comment">// conditional deletion
</span><span class="macro">assert_eq!</span>(
    db.compare_and_swap(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">20</span>]), <span class="prelude-val">None </span><span class="kw">as </span><span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>[u8]&gt;),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Ok</span>(()))
);
<span class="macro">assert_eq!</span>(db.get(<span class="kw-2">&amp;</span>[<span class="number">1</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.update_and_fetch" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#642-669">source</a><h4 class="code-header">pub fn <a href="#method.update_and_fetch" class="fn">update_and_fetch</a>&lt;K, V, F&gt;(&amp;self, key: K, f: F) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Fetch the value, apply a function to it and return the result.</p>
<h5 id="note"><a href="#note">Note</a></h5>
<p>This may call the function multiple times if the value has been
changed from other threads in the meantime.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::{Config, Error, IVec};
<span class="kw">use </span>std::convert::TryInto;

<span class="kw">let </span>config = Config::new().temporary(<span class="bool-val">true</span>);
<span class="kw">let </span>db = config.open()<span class="question-mark">?</span>;

<span class="kw">fn </span>u64_to_ivec(number: u64) -&gt; IVec {
    IVec::from(number.to_be_bytes().to_vec())
}

<span class="kw">let </span>zero = u64_to_ivec(<span class="number">0</span>);
<span class="kw">let </span>one = u64_to_ivec(<span class="number">1</span>);
<span class="kw">let </span>two = u64_to_ivec(<span class="number">2</span>);
<span class="kw">let </span>three = u64_to_ivec(<span class="number">3</span>);

<span class="kw">fn </span>increment(old: <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>[u8]&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;Vec&lt;u8&gt;&gt; {
    <span class="kw">let </span>number = <span class="kw">match </span>old {
        <span class="prelude-val">Some</span>(bytes) =&gt; {
            <span class="kw">let </span>array: [u8; <span class="number">8</span>] = bytes.try_into().unwrap();
            <span class="kw">let </span>number = u64::from_be_bytes(array);
            number + <span class="number">1
        </span>}
        <span class="prelude-val">None </span>=&gt; <span class="number">0</span>,
    };

    <span class="prelude-val">Some</span>(number.to_be_bytes().to_vec())
}

<span class="macro">assert_eq!</span>(db.update_and_fetch(<span class="string">"counter"</span>, increment), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(zero)));
<span class="macro">assert_eq!</span>(db.update_and_fetch(<span class="string">"counter"</span>, increment), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(one)));
<span class="macro">assert_eq!</span>(db.update_and_fetch(<span class="string">"counter"</span>, increment), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(two)));
<span class="macro">assert_eq!</span>(db.update_and_fetch(<span class="string">"counter"</span>, increment), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(three)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fetch_and_update" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#715-738">source</a><h4 class="code-header">pub fn <a href="#method.fetch_and_update" class="fn">fetch_and_update</a>&lt;K, V, F&gt;(&amp;self, key: K, f: F) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Fetch the value, apply a function to it and return the previous value.</p>
<h5 id="note-1"><a href="#note-1">Note</a></h5>
<p>This may call the function multiple times if the value has been
changed from other threads in the meantime.</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::{Config, Error, IVec};
<span class="kw">use </span>std::convert::TryInto;

<span class="kw">let </span>config = Config::new().temporary(<span class="bool-val">true</span>);
<span class="kw">let </span>db = config.open()<span class="question-mark">?</span>;

<span class="kw">fn </span>u64_to_ivec(number: u64) -&gt; IVec {
    IVec::from(number.to_be_bytes().to_vec())
}

<span class="kw">let </span>zero = u64_to_ivec(<span class="number">0</span>);
<span class="kw">let </span>one = u64_to_ivec(<span class="number">1</span>);
<span class="kw">let </span>two = u64_to_ivec(<span class="number">2</span>);

<span class="kw">fn </span>increment(old: <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>[u8]&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;Vec&lt;u8&gt;&gt; {
    <span class="kw">let </span>number = <span class="kw">match </span>old {
        <span class="prelude-val">Some</span>(bytes) =&gt; {
            <span class="kw">let </span>array: [u8; <span class="number">8</span>] = bytes.try_into().unwrap();
            <span class="kw">let </span>number = u64::from_be_bytes(array);
            number + <span class="number">1
        </span>}
        <span class="prelude-val">None </span>=&gt; <span class="number">0</span>,
    };

    <span class="prelude-val">Some</span>(number.to_be_bytes().to_vec())
}

<span class="macro">assert_eq!</span>(db.fetch_and_update(<span class="string">"counter"</span>, increment), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));
<span class="macro">assert_eq!</span>(db.fetch_and_update(<span class="string">"counter"</span>, increment), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(zero)));
<span class="macro">assert_eq!</span>(db.fetch_and_update(<span class="string">"counter"</span>, increment), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(one)));
<span class="macro">assert_eq!</span>(db.fetch_and_update(<span class="string">"counter"</span>, increment), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(two)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.watch_prefix" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#784-786">source</a><h4 class="code-header">pub fn <a href="#method.watch_prefix" class="fn">watch_prefix</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, prefix: P) -&gt; <a class="struct" href="struct.Subscriber.html" title="struct sled::Subscriber">Subscriber</a> <a href="#" class="tooltip" data-notable-ty="Subscriber">ⓘ</a></h4></section></summary><div class="docblock"><p>Subscribe to <code>Event</code>s that happen to keys that have
the specified prefix. Events for particular keys are
guaranteed to be witnessed in the same order by all
threads, but threads may witness different interleavings
of <code>Event</code>s across different keys. If subscribers don’t
keep up with new writes, they will cause new writes
to block. There is a buffer of 1024 items per
<code>Subscriber</code>. This can be used to build reactive
and replicated systems.</p>
<p><code>Subscriber</code> implements both <code>Iterator&lt;Item = Event&gt;</code>
and <code>Future&lt;Output=Option&lt;Event&gt;&gt;</code></p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<p>Synchronous, blocking subscriber:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// watch all events by subscribing to the empty prefix
</span><span class="kw">let </span><span class="kw-2">mut </span>subscriber = db.watch_prefix(<span class="macro">vec!</span>[]);

<span class="kw">let </span>tree_2 = db.clone();
<span class="kw">let </span>thread = std::thread::spawn(<span class="kw">move </span>|| {
    db.insert(<span class="macro">vec!</span>[<span class="number">0</span>], <span class="macro">vec!</span>[<span class="number">1</span>])
});

<span class="comment">// `Subscription` implements `Iterator&lt;Item=Event&gt;`
</span><span class="kw">for </span>event <span class="kw">in </span>subscriber.take(<span class="number">1</span>) {
    <span class="kw">match </span>event {
        sled::Event::Insert{ key, value } =&gt; <span class="macro">assert_eq!</span>(key.as_ref(), <span class="kw-2">&amp;</span>[<span class="number">0</span>]),
        sled::Event::Remove {key } =&gt; {}
    }
}
</code></pre></div>
<p>Aynchronous, non-blocking subscriber:</p>
<p><code>Subscription</code> implements <code>Future&lt;Output=Option&lt;Event&gt;&gt;</code>.</p>
<p><code>while let Some(event) = (&amp;mut subscriber).await { /* use it */ }</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flush" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#798-800">source</a><h4 class="code-header">pub fn <a href="#method.flush" class="fn">flush</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Synchronously flushes all dirty IO buffers and calls
fsync. If this succeeds, it is guaranteed that all
previous writes will be recovered if the system
crashes. Returns the number of bytes flushed during
this call.</p>
<p>Flushing can take quite a lot of time, and you should
measure the performance impact of using it on
realistic sustained workloads running on realistic
hardware.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flush_async" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#814-826">source</a><h4 class="code-header">pub async fn <a href="#method.flush_async" class="fn">flush_async</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Asynchronously flushes all dirty IO buffers
and calls fsync. If this succeeds, it is
guaranteed that all previous writes will
be recovered if the system crashes. Returns
the number of bytes flushed during this call.</p>
<p>Flushing can take quite a lot of time, and you
should measure the performance impact of
using it on realistic sustained workloads
running on realistic hardware.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains_key" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#842-844">source</a><h4 class="code-header">pub fn <a href="#method.contains_key" class="fn">contains_key</a>&lt;K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt;(&amp;self, key: K) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the <code>Tree</code> contains a value for
the specified key.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>], <span class="macro">vec!</span>[<span class="number">0</span>])<span class="question-mark">?</span>;
<span class="macro">assert!</span>(db.contains_key(<span class="kw-2">&amp;</span>[<span class="number">0</span>])<span class="question-mark">?</span>);
<span class="macro">assert!</span>(!db.contains_key(<span class="kw-2">&amp;</span>[<span class="number">1</span>])<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_lt" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#881-887">source</a><h4 class="code-header">pub fn <a href="#method.get_lt" class="fn">get_lt</a>&lt;K&gt;(&amp;self, key: K) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>, <a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>)&gt;&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section></summary><div class="docblock"><p>Retrieve the key and value before the provided key,
if one exists.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::IVec;
<span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">10 </span>{
    db.insert(<span class="kw-2">&amp;</span>[i], <span class="macro">vec!</span>[i])
        .expect(<span class="string">"should write successfully"</span>);
}

<span class="macro">assert_eq!</span>(db.get_lt(<span class="kw-2">&amp;</span>[]), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));
<span class="macro">assert_eq!</span>(db.get_lt(<span class="kw-2">&amp;</span>[<span class="number">0</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));
<span class="macro">assert_eq!</span>(
    db.get_lt(<span class="kw-2">&amp;</span>[<span class="number">1</span>]),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>]))))
);
<span class="macro">assert_eq!</span>(
    db.get_lt(<span class="kw-2">&amp;</span>[<span class="number">9</span>]),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">8</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">8</span>]))))
);
<span class="macro">assert_eq!</span>(
    db.get_lt(<span class="kw-2">&amp;</span>[<span class="number">10</span>]),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">9</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">9</span>]))))
);
<span class="macro">assert_eq!</span>(
    db.get_lt(<span class="kw-2">&amp;</span>[<span class="number">255</span>]),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">9</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">9</span>]))))
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_gt" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#935-943">source</a><h4 class="code-header">pub fn <a href="#method.get_gt" class="fn">get_gt</a>&lt;K&gt;(&amp;self, key: K) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>, <a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>)&gt;&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section></summary><div class="docblock"><p>Retrieve the next key and value from the <code>Tree</code> after the
provided key.</p>
<h5 id="note-2"><a href="#note-2">Note</a></h5>
<p>The order follows the Ord implementation for <code>Vec&lt;u8&gt;</code>:</p>
<p><code>[] &lt; [0] &lt; [255] &lt; [255, 0] &lt; [255, 255] ...</code></p>
<p>To retain the ordering of numerical types use big endian reprensentation</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::IVec;
<span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">10 </span>{
    db.insert(<span class="kw-2">&amp;</span>[i], <span class="macro">vec!</span>[i])<span class="question-mark">?</span>;
}

<span class="macro">assert_eq!</span>(
    db.get_gt(<span class="kw-2">&amp;</span>[]),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>]))))
);
<span class="macro">assert_eq!</span>(
    db.get_gt(<span class="kw-2">&amp;</span>[<span class="number">0</span>]),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">1</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">1</span>]))))
);
<span class="macro">assert_eq!</span>(
    db.get_gt(<span class="kw-2">&amp;</span>[<span class="number">1</span>]),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">2</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">2</span>]))))
);
<span class="macro">assert_eq!</span>(
    db.get_gt(<span class="kw-2">&amp;</span>[<span class="number">8</span>]),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">9</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">9</span>]))))
);
<span class="macro">assert_eq!</span>(db.get_gt(<span class="kw-2">&amp;</span>[<span class="number">9</span>]), <span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>));

db.insert(<span class="number">500u16</span>.to_be_bytes(), <span class="macro">vec!</span>[<span class="number">10</span>]);
<span class="macro">assert_eq!</span>(
    db.get_gt(<span class="kw-2">&amp;</span><span class="number">499u16</span>.to_be_bytes()),
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>((IVec::from(<span class="kw-2">&amp;</span><span class="number">500u16</span>.to_be_bytes()), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">10</span>]))))
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.merge" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1001-1012">source</a><h4 class="code-header">pub fn <a href="#method.merge" class="fn">merge</a>&lt;K, V&gt;(&amp;self, key: K, value: V) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>&gt;&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
    V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section></summary><div class="docblock"><p>Merge state directly into a given key’s value using the
configured merge operator. This allows state to be written
into a value directly, without any read-modify-write steps.
Merge operators can be used to implement arbitrary data
structures.</p>
<p>Calling <code>merge</code> will return an <code>Unsupported</code> error if it
is called without first setting a merge operator function.</p>
<p>Merge operators are shared by all instances of a particular
<code>Tree</code>. Different merge operators may be set on different
<code>Tree</code>s.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::IVec;

<span class="kw">fn </span>concatenate_merge(
  _key: <span class="kw-2">&amp;</span>[u8],               <span class="comment">// the key being merged
  </span>old_value: <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>[u8]&gt;,  <span class="comment">// the previous value, if one existed
  </span>merged_bytes: <span class="kw-2">&amp;</span>[u8]        <span class="comment">// the new bytes being merged in
</span>) -&gt; <span class="prelude-ty">Option</span>&lt;Vec&lt;u8&gt;&gt; {       <span class="comment">// set the new value, return None to delete
  </span><span class="kw">let </span><span class="kw-2">mut </span>ret = old_value
    .map(|ov| ov.to_vec())
    .unwrap_or_else(|| <span class="macro">vec!</span>[]);

  ret.extend_from_slice(merged_bytes);

  <span class="prelude-val">Some</span>(ret)
}

db.set_merge_operator(concatenate_merge);

<span class="kw">let </span>k = <span class="string">b"k1"</span>;

db.insert(k, <span class="macro">vec!</span>[<span class="number">0</span>]);
db.merge(k, <span class="macro">vec!</span>[<span class="number">1</span>]);
db.merge(k, <span class="macro">vec!</span>[<span class="number">2</span>]);
<span class="macro">assert_eq!</span>(db.get(k), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(IVec::from(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))));

<span class="comment">// Replace previously merged data. The merge function will not be called.
</span>db.insert(k, <span class="macro">vec!</span>[<span class="number">3</span>]);
<span class="macro">assert_eq!</span>(db.get(k), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(IVec::from(<span class="macro">vec!</span>[<span class="number">3</span>]))));

<span class="comment">// Merges on non-present values will cause the merge function to be called
// with `old_value == None`. If the merge function returns something (which it
// does, in this case) a new value will be inserted.
</span>db.remove(k);
db.merge(k, <span class="macro">vec!</span>[<span class="number">4</span>]);
<span class="macro">assert_eq!</span>(db.get(k), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(IVec::from(<span class="macro">vec!</span>[<span class="number">4</span>]))));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_merge_operator" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1131-1137">source</a><h4 class="code-header">pub fn <a href="#method.set_merge_operator" class="fn">set_merge_operator</a>(&amp;self, merge_operator: impl <a class="trait" href="trait.MergeOperator.html" title="trait sled::MergeOperator">MergeOperator</a> + 'static)</h4></section></summary><div class="docblock"><p>Sets a merge operator for use with the <code>merge</code> function.</p>
<p>Merge state directly into a given key’s value using the
configured merge operator. This allows state to be written
into a value directly, without any read-modify-write steps.
Merge operators can be used to implement arbitrary data
structures.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Calling <code>merge</code> will panic if no merge operator has been
configured.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::IVec;

<span class="kw">fn </span>concatenate_merge(
  _key: <span class="kw-2">&amp;</span>[u8],               <span class="comment">// the key being merged
  </span>old_value: <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>[u8]&gt;,  <span class="comment">// the previous value, if one existed
  </span>merged_bytes: <span class="kw-2">&amp;</span>[u8]        <span class="comment">// the new bytes being merged in
</span>) -&gt; <span class="prelude-ty">Option</span>&lt;Vec&lt;u8&gt;&gt; {       <span class="comment">// set the new value, return None to delete
  </span><span class="kw">let </span><span class="kw-2">mut </span>ret = old_value
    .map(|ov| ov.to_vec())
    .unwrap_or_else(|| <span class="macro">vec!</span>[]);

  ret.extend_from_slice(merged_bytes);

  <span class="prelude-val">Some</span>(ret)
}

db.set_merge_operator(concatenate_merge);

<span class="kw">let </span>k = <span class="string">b"k1"</span>;

db.insert(k, <span class="macro">vec!</span>[<span class="number">0</span>]);
db.merge(k, <span class="macro">vec!</span>[<span class="number">1</span>]);
db.merge(k, <span class="macro">vec!</span>[<span class="number">2</span>]);
<span class="macro">assert_eq!</span>(db.get(k), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(IVec::from(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))));

<span class="comment">// Replace previously merged data. The merge function will not be called.
</span>db.insert(k, <span class="macro">vec!</span>[<span class="number">3</span>]);
<span class="macro">assert_eq!</span>(db.get(k), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(IVec::from(<span class="macro">vec!</span>[<span class="number">3</span>]))));

<span class="comment">// Merges on non-present values will cause the merge function to be called
// with `old_value == None`. If the merge function returns something (which it
// does, in this case) a new value will be inserted.
</span>db.remove(k);
db.merge(k, <span class="macro">vec!</span>[<span class="number">4</span>]);
<span class="macro">assert_eq!</span>(db.get(k), <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(IVec::from(<span class="macro">vec!</span>[<span class="number">4</span>]))));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1168-1170">source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct sled::Iter">Iter</a> <a href="#" class="tooltip" data-notable-ty="Iter">ⓘ</a></h4></section></summary><div class="docblock"><p>Create a double-ended iterator over the tuples of keys and
values in this tree.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::IVec;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="macro">vec!</span>[<span class="number">10</span>]);
db.insert(<span class="kw-2">&amp;</span>[<span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">20</span>]);
db.insert(<span class="kw-2">&amp;</span>[<span class="number">3</span>], <span class="macro">vec!</span>[<span class="number">30</span>]);
<span class="kw">let </span><span class="kw-2">mut </span>iter = db.iter();
<span class="macro">assert_eq!</span>(
    iter.next().unwrap(),
    <span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">1</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">10</span>])))
);
<span class="macro">assert_eq!</span>(
    iter.next().unwrap(),
    <span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">2</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">20</span>])))
);
<span class="macro">assert_eq!</span>(
    iter.next().unwrap(),
    <span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">3</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">30</span>])))
);
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.range" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1202-1234">source</a><h4 class="code-header">pub fn <a href="#method.range" class="fn">range</a>&lt;K, R&gt;(&amp;self, range: R) -&gt; <a class="struct" href="struct.Iter.html" title="struct sled::Iter">Iter</a> <a href="#" class="tooltip" data-notable-ty="Iter">ⓘ</a><div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
    R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;K&gt;,</div></h4></section></summary><div class="docblock"><p>Create a double-ended iterator over tuples of keys and values,
where the keys fall within the specified range.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::IVec;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>], <span class="macro">vec!</span>[<span class="number">0</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="macro">vec!</span>[<span class="number">10</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">20</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">3</span>], <span class="macro">vec!</span>[<span class="number">30</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">4</span>], <span class="macro">vec!</span>[<span class="number">40</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">5</span>], <span class="macro">vec!</span>[<span class="number">50</span>])<span class="question-mark">?</span>;

<span class="kw">let </span>start: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">2</span>];
<span class="kw">let </span>end: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">4</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = db.range(start..end);
<span class="macro">assert_eq!</span>(r.next().unwrap(), <span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">2</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">20</span>]))));
<span class="macro">assert_eq!</span>(r.next().unwrap(), <span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">3</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">30</span>]))));
<span class="macro">assert_eq!</span>(r.next(), <span class="prelude-val">None</span>);

<span class="kw">let </span><span class="kw-2">mut </span>r = db.range(start..end).rev();
<span class="macro">assert_eq!</span>(r.next().unwrap(), <span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">3</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">30</span>]))));
<span class="macro">assert_eq!</span>(r.next().unwrap(), <span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">2</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">20</span>]))));
<span class="macro">assert_eq!</span>(r.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.scan_prefix" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1274-1289">source</a><h4 class="code-header">pub fn <a href="#method.scan_prefix" class="fn">scan_prefix</a>&lt;P&gt;(&amp;self, prefix: P) -&gt; <a class="struct" href="struct.Iter.html" title="struct sled::Iter">Iter</a> <a href="#" class="tooltip" data-notable-ty="Iter">ⓘ</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section></summary><div class="docblock"><p>Create an iterator over tuples of keys and values,
where the all the keys starts with the given prefix.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>sled::IVec;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>], <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>])<span class="question-mark">?</span>;

<span class="kw">let </span>prefix: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>r = db.scan_prefix(prefix);
<span class="macro">assert_eq!</span>(
    r.next(),
    <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]))))
);
<span class="macro">assert_eq!</span>(
    r.next(),
    <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]))))
);
<span class="macro">assert_eq!</span>(
    r.next(),
    <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]))))
);
<span class="macro">assert_eq!</span>(
    r.next(),
    <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>((IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>]), IVec::from(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>]))))
);
<span class="macro">assert_eq!</span>(r.next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1293-1295">source</a><h4 class="code-header">pub fn <a href="#method.first" class="fn">first</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>, <a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>)&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the first key and value in the <code>Tree</code>, or
<code>None</code> if the <code>Tree</code> is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1299-1301">source</a><h4 class="code-header">pub fn <a href="#method.last" class="fn">last</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>, <a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>)&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the last key and value in the <code>Tree</code>, or
<code>None</code> if the <code>Tree</code> is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_max" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1327-1346">source</a><h4 class="code-header">pub fn <a href="#method.pop_max" class="fn">pop_max</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>, <a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>)&gt;&gt;</h4></section></summary><div class="docblock"><p>Atomically removes the maximum item in the <code>Tree</code> instance.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>], <span class="macro">vec!</span>[<span class="number">0</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="macro">vec!</span>[<span class="number">10</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">20</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">3</span>], <span class="macro">vec!</span>[<span class="number">30</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">4</span>], <span class="macro">vec!</span>[<span class="number">40</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">5</span>], <span class="macro">vec!</span>[<span class="number">50</span>])<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_max()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">5</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_max()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_max()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_max()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">2</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_max()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_max()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(db.pop_max()<span class="question-mark">?</span>, <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_min" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1372-1391">source</a><h4 class="code-header">pub fn <a href="#method.pop_min" class="fn">pop_min</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>, <a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>)&gt;&gt;</h4></section></summary><div class="docblock"><p>Atomically removes the minimum item in the <code>Tree</code> instance.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>db.insert(<span class="kw-2">&amp;</span>[<span class="number">0</span>], <span class="macro">vec!</span>[<span class="number">0</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="macro">vec!</span>[<span class="number">10</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">20</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">3</span>], <span class="macro">vec!</span>[<span class="number">30</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">4</span>], <span class="macro">vec!</span>[<span class="number">40</span>])<span class="question-mark">?</span>;
db.insert(<span class="kw-2">&amp;</span>[<span class="number">5</span>], <span class="macro">vec!</span>[<span class="number">50</span>])<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_min()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_min()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_min()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">2</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_min()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_min()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>db.pop_min()<span class="question-mark">?</span>.unwrap().<span class="number">0</span>, <span class="kw-2">&amp;</span>[<span class="number">5</span>]);
<span class="macro">assert_eq!</span>(db.pop_min()<span class="question-mark">?</span>, <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1408-1410">source</a><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of elements in this tree.</p>
<p>Beware: performs a full O(n) scan under the hood.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>db.insert(<span class="string">b"a"</span>, <span class="macro">vec!</span>[<span class="number">0</span>]);
db.insert(<span class="string">b"b"</span>, <span class="macro">vec!</span>[<span class="number">1</span>]);
<span class="macro">assert_eq!</span>(db.len(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1413-1415">source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the <code>Tree</code> contains no elements.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1420-1426">source</a><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Clears the <code>Tree</code>, removing all values.</p>
<p>Note that this is not atomic.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.name" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1429-1431">source</a><h4 class="code-header">pub fn <a href="#method.name" class="fn">name</a>(&amp;self) -&gt; <a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a></h4></section></summary><div class="docblock"><p>Returns the name of the tree.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checksum" class="method"><a class="src rightside" href="../src/sled/tree.rs.html#1438-1448">source</a><h4 class="code-header">pub fn <a href="#method.checksum" class="fn">checksum</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the CRC32 of all keys and values
in this Tree.</p>
<p>This is O(N) and locks the underlying tree
for the duration of the entire scan.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Tree" class="impl"><a class="src rightside" href="../src/sled/tree.rs.html#86">source</a><a href="#impl-Clone-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/sled/tree.rs.html#86">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Tree" class="impl"><a class="src rightside" href="../src/sled/tree.rs.html#2136-2249">source</a><a href="#impl-Debug-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/sled/tree.rs.html#2137-2248">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-Tree" class="impl"><a class="src rightside" href="../src/sled/tree.rs.html#115-121">source</a><a href="#impl-Deref-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = TreeInner</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../src/sled/tree.rs.html#118-120">source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;TreeInner</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26Tree" class="impl"><a class="src rightside" href="../src/sled/tree.rs.html#28-35">source</a><a href="#impl-IntoIterator-for-%26Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;<a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a href="#associatedtype.Item" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>, <a class="struct" href="struct.IVec.html" title="struct sled::IVec">IVec</a>), <a class="enum" href="enum.Error.html" title="enum sled::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a href="#associatedtype.IntoIter" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct sled::Iter">Iter</a></h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="../src/sled/tree.rs.html#32-34">source</a><a href="#method.into_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; <a class="struct" href="struct.Iter.html" title="struct sled::Iter">Iter</a> <a href="#" class="tooltip" data-notable-ty="Iter">ⓘ</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Transactional%3CE%3E-for-%26Tree" class="impl"><a class="src rightside" href="../src/sled/transaction.rs.html#497-509">source</a><a href="#impl-Transactional%3CE%3E-for-%26Tree" class="anchor">§</a><h3 class="code-header">impl&lt;E&gt; <a class="trait" href="transaction/trait.Transactional.html" title="trait sled::transaction::Transactional">Transactional</a>&lt;E&gt; for &amp;<a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.View-1" class="associatedtype trait-impl"><a href="#associatedtype.View-1" class="anchor">§</a><h4 class="code-header">type <a href="transaction/trait.Transactional.html#associatedtype.View" class="associatedtype">View</a> = <a class="struct" href="transaction/struct.TransactionalTree.html" title="struct sled::transaction::TransactionalTree">TransactionalTree</a></h4></section></summary><div class='docblock'>An internal reference to an internal proxy type that
mediates transactional reads and writes.</div></details><details class="toggle method-toggle" open><summary><section id="method.make_overlay-1" class="method trait-impl"><a class="src rightside" href="../src/sled/transaction.rs.html#500-504">source</a><a href="#method.make_overlay-1" class="anchor">§</a><h4 class="code-header">fn <a href="transaction/trait.Transactional.html#tymethod.make_overlay" class="fn">make_overlay</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="struct" href="transaction/struct.TransactionalTrees.html" title="struct sled::transaction::TransactionalTrees">TransactionalTrees</a>&gt;</h4></section></summary><div class='docblock'>An internal function for creating a top-level
transactional structure.</div></details><details class="toggle method-toggle" open><summary><section id="method.view_overlay-1" class="method trait-impl"><a class="src rightside" href="../src/sled/transaction.rs.html#506-508">source</a><a href="#method.view_overlay-1" class="anchor">§</a><h4 class="code-header">fn <a href="transaction/trait.Transactional.html#tymethod.view_overlay" class="fn">view_overlay</a>(overlay: &amp;<a class="struct" href="transaction/struct.TransactionalTrees.html" title="struct sled::transaction::TransactionalTrees">TransactionalTrees</a>) -&gt; Self::<a class="associatedtype" href="transaction/trait.Transactional.html#associatedtype.View" title="type sled::transaction::Transactional::View">View</a></h4></section></summary><div class='docblock'>An internal function for viewing the transactional
subcomponents based on the top-level transactional
structure.</div></details><details class="toggle method-toggle" open><summary><section id="method.transaction-2" class="method trait-impl"><a class="src rightside" href="../src/sled/transaction.rs.html#457-494">source</a><a href="#method.transaction-2" class="anchor">§</a><h4 class="code-header">fn <a href="transaction/trait.Transactional.html#method.transaction" class="fn">transaction</a>&lt;F, A&gt;(&amp;self, f: F) -&gt; <a class="type" href="transaction/type.TransactionResult.html" title="type sled::transaction::TransactionResult">TransactionResult</a>&lt;A, E&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;Self::<a class="associatedtype" href="transaction/trait.Transactional.html#associatedtype.View" title="type sled::transaction::Transactional::View">View</a>) -&gt; <a class="type" href="transaction/type.ConflictableTransactionResult.html" title="type sled::transaction::ConflictableTransactionResult">ConflictableTransactionResult</a>&lt;A, E&gt;,</div></h4></section></summary><div class='docblock'>Runs a transaction, possibly retrying the passed-in closure if
a concurrent conflict is detected that would cause a violation
of serializability. This is the only trait method that
you’re most likely to use directly.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Transactional%3CE%3E-for-Tree" class="impl"><a class="src rightside" href="../src/sled/transaction.rs.html#525-537">source</a><a href="#impl-Transactional%3CE%3E-for-Tree" class="anchor">§</a><h3 class="code-header">impl&lt;E&gt; <a class="trait" href="transaction/trait.Transactional.html" title="trait sled::transaction::Transactional">Transactional</a>&lt;E&gt; for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.View" class="associatedtype trait-impl"><a href="#associatedtype.View" class="anchor">§</a><h4 class="code-header">type <a href="transaction/trait.Transactional.html#associatedtype.View" class="associatedtype">View</a> = <a class="struct" href="transaction/struct.TransactionalTree.html" title="struct sled::transaction::TransactionalTree">TransactionalTree</a></h4></section></summary><div class='docblock'>An internal reference to an internal proxy type that
mediates transactional reads and writes.</div></details><details class="toggle method-toggle" open><summary><section id="method.make_overlay" class="method trait-impl"><a class="src rightside" href="../src/sled/transaction.rs.html#528-532">source</a><a href="#method.make_overlay" class="anchor">§</a><h4 class="code-header">fn <a href="transaction/trait.Transactional.html#tymethod.make_overlay" class="fn">make_overlay</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type sled::Result">Result</a>&lt;<a class="struct" href="transaction/struct.TransactionalTrees.html" title="struct sled::transaction::TransactionalTrees">TransactionalTrees</a>&gt;</h4></section></summary><div class='docblock'>An internal function for creating a top-level
transactional structure.</div></details><details class="toggle method-toggle" open><summary><section id="method.view_overlay" class="method trait-impl"><a class="src rightside" href="../src/sled/transaction.rs.html#534-536">source</a><a href="#method.view_overlay" class="anchor">§</a><h4 class="code-header">fn <a href="transaction/trait.Transactional.html#tymethod.view_overlay" class="fn">view_overlay</a>(overlay: &amp;<a class="struct" href="transaction/struct.TransactionalTrees.html" title="struct sled::transaction::TransactionalTrees">TransactionalTrees</a>) -&gt; Self::<a class="associatedtype" href="transaction/trait.Transactional.html#associatedtype.View" title="type sled::transaction::Transactional::View">View</a></h4></section></summary><div class='docblock'>An internal function for viewing the transactional
subcomponents based on the top-level transactional
structure.</div></details><details class="toggle method-toggle" open><summary><section id="method.transaction-1" class="method trait-impl"><a class="src rightside" href="../src/sled/transaction.rs.html#457-494">source</a><a href="#method.transaction-1" class="anchor">§</a><h4 class="code-header">fn <a href="transaction/trait.Transactional.html#method.transaction" class="fn">transaction</a>&lt;F, A&gt;(&amp;self, f: F) -&gt; <a class="type" href="transaction/type.TransactionResult.html" title="type sled::transaction::TransactionResult">TransactionResult</a>&lt;A, E&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;Self::<a class="associatedtype" href="transaction/trait.Transactional.html#associatedtype.View" title="type sled::transaction::Transactional::View">View</a>) -&gt; <a class="type" href="transaction/type.ConflictableTransactionResult.html" title="type sled::transaction::ConflictableTransactionResult">ConflictableTransactionResult</a>&lt;A, E&gt;,</div></h4></section></summary><div class='docblock'>Runs a transaction, possibly retrying the passed-in closure if
a concurrent conflict is detected that would cause a violation
of serializability. This is the only trait method that
you’re most likely to use directly.</div></details></div></details><section id="impl-Send-for-Tree" class="impl"><a class="src rightside" href="../src/sled/tree.rs.html#124">source</a><a href="#impl-Send-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section><section id="impl-Sync-for-Tree" class="impl"><a class="src rightside" href="../src/sled/tree.rs.html#127">source</a><a href="#impl-Sync-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Tree" class="impl"><a href="#impl-RefUnwindSafe-for-Tree" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section><section id="impl-Unpin-for-Tree" class="impl"><a href="#impl-Unpin-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section><section id="impl-UnwindSafe-for-Tree" class="impl"><a href="#impl-UnwindSafe-for-Tree" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Tree.html" title="struct sled::Tree">Tree</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#766">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a class="src rightside" href="../src/crossbeam_epoch/atomic.rs.html#193">source</a><a href="#impl-Pointable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a class="src rightside" href="../src/crossbeam_epoch/atomic.rs.html#194">source</a><a href="#associatedconstant.ALIGN" class="anchor">§</a><h4 class="code-header">const <a href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedconstant.ALIGN" class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">§</a><h4 class="code-header">type <a href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a class="src rightside" href="../src/crossbeam_epoch/atomic.rs.html#198">source</a><a href="#method.init" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init" class="fn">init</a>(init: &lt;T as <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a>&gt;::<a class="associatedtype" href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" title="type crossbeam_epoch::atomic::Pointable::Init">Init</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref-1" class="method trait-impl"><a class="src rightside" href="../src/crossbeam_epoch/atomic.rs.html#202">source</a><a href="#method.deref-1" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref" class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a class="src rightside" href="../src/crossbeam_epoch/atomic.rs.html#206">source</a><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut" class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../src/crossbeam_epoch/atomic.rs.html#210">source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop" class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"Iter":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct sled::Iter\">Iter</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct sled::Iter\">Iter</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"type\" href=\"type.Result.html\" title=\"type sled::Result\">Result</a>&lt;(<a class=\"struct\" href=\"struct.IVec.html\" title=\"struct sled::IVec\">IVec</a>, <a class=\"struct\" href=\"struct.IVec.html\" title=\"struct sled::IVec\">IVec</a>)&gt;;</div>","Subscriber":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Subscriber.html\" title=\"struct sled::Subscriber\">Subscriber</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Subscriber.html\" title=\"struct sled::Subscriber\">Subscriber</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"enum.Event.html\" title=\"enum sled::Event\">Event</a>;</div><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html\" title=\"trait core::future::future::Future\">Future</a> for <a class=\"struct\" href=\"struct.Subscriber.html\" title=\"struct sled::Subscriber\">Subscriber</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"enum.Event.html\" title=\"enum sled::Event\">Event</a>&gt;;</div>"}</script></section></div></main></body></html>